/****************************************************************************
 *                                                                          *
 *                            CANIO2 Lib Project.                           *
 *                                                                          *
 ****************************************************************************/
/**
 @file 
 ****************************************************************************
 @brief     Abstract classes for CAN module and CAN interface
 ****************************************************************************
 @details   CAN module is a plugin (dynamic link lib) or just internal module
 ****************************************************************************
 @author    gruzovator 
 ****************************************************************************/
#ifndef CAN_MODULE_HPP_
#define CAN_MODULE_HPP_

#include "canio_common.hpp"

CANIO_NS_START

struct CANModuleError : Error {
    CANModuleError(const std::string& str="") : Error(str){}
};
typedef CANModuleError CANModuleException;

struct IOError : Error {
    IOError(const std::string& str="") : Error(str){}
};
typedef IOError IOException;

struct CANIface;
struct CANModule;

typedef std::vector<std::string> strlist_t;
/// smart pointer to CANIface object
typedef boost::shared_ptr<CANIface> can_iface_sp_t;
/// smart pointer to CANModule object
typedef boost::shared_ptr<CANModule> can_module_sp_t;

/** CAN interface abstract class.
    CAN interface instance is generated by concrete CANModule.*/
struct CANIface
{
    CANIface(){}
    virtual ~CANIface(){}

    /** Sends CAN message with timeout.
        @return true on successfull send, false on timeout
        @throw IOException*/
    virtual bool send(const canmsg_t& m, uint timeout_ms) = 0;

    /** Receives CAN message with timeout.
        @return true on successfull msg receiving, false on timeout
        @throw IOException*/
    virtual bool recv(canmsg_t& m, uint timeout_ms) = 0;

    /** @name Filtering functions.
            There are two filteres for CAN iface. First one is acceptance
        filter. If messages passes this filter it goes to iface client.
        Otherwise it goes to list of id filteres. So, second filter is
        actually is a list of filteres. If messages pass one of id filteres
        it goes to the client, otherwise it is rejected.
        This filtering methods is adopted from IXXAT VCI3 driver.\n
            Some plugins need to switch off iface to apply filteres, so
        do this carefully.\n
            Eache filter consists of code and mask.
            Attention! Not all ifaces supports filtering.
        @param code lowest 12 bits are used. 0 bit is RTR, others are
            CAN message ID
        @param mask lowest 12 bits used. If mask bit is '1', checked message 
            bit should be equal to respective bit of code to pass the filter. */
    //@{
    /// Resets acceptance filter
    virtual void set_acc_filter(uint32_t code, uint32_t mask) = 0;
    /// Adds id filter to the list of id filteres
    virtual void add_id_filter(uint32_t code, uint32_t mask) = 0;
    /// Removes id filter from the list of id filteres
    virtual void rem_id_filter(uint32_t code, uint32_t mask) = 0;
    //@}

    virtual std::string id() const = 0; ///< iface id getter
    virtual can_module_sp_t module() const = 0;
};

/** CAN Module abstract class.
    CAN Module is an object that represents type of CAN interface 
    (e.g. "IXXAT USB-to-CAN").\n
    CAN Modules can be external (dll) or internal (just a concrete successor of
    this class). */
struct CANModule 
{
    virtual ~CANModule(){}
    /// module name
    virtual std::string name() const = 0;
    /// iface instance id name, e.g. "HW id" or "IP Address"
    virtual std::string id_name() const = 0;
    /// iface param name, e.g. "bitrate" or "port" 
    virtual std::string param_name() const = 0;
    /// list of params, e,g, supported bitrates
    virtual strlist_t params() const = 0;
    /// list of available ids
    virtual strlist_t ids() const = 0;
    /** iface factory
        @return smart pointer to created iface
        @throw CANModuleException */
    virtual can_iface_sp_t make_iface(const std::string& id,const std::string& param) = 0;
};

CANIO_NS_END

#endif /* CAN_MODULE_HPP_ */
